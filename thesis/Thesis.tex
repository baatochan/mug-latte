\documentclass[polish,polish,a4paper,12pt]{article}

\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pmboxdraw}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{color}
\usepackage{pslatex}
\usepackage{anysize}
\usepackage{siunitx}
\usepackage{multicol}
\usepackage{printlen}

\usepackage[
	backend=biber,
	style=numeric,
	sorting=none
]{biblatex}
\addbibresource{thesis.bib}

\graphicspath{ {./img/} }

\geometry{
	a4paper,
	left = 2.5cm,
	right = 2.5cm,
	top = 2cm,
	bottom = 2cm
}
\setlength{\columnsep}{-2cm}
\setlength{\baselineskip}{1.5em}

\renewcommand{\figurename}{Ryc.}
\renewcommand*{\contentsname}{Spis treści}
\renewcommand{\listfigurename}{Indeks rycin}
\renewcommand{\listoflistingscaption}{Indeks listingów}

\let\sectioncmd\section
\renewcommand{\section}{\clearpage\sectioncmd}

\title{Aplikacja mobilna na platformę Android umożliwiająca użytkowanie i uzupełnianie tworzonej społecznościowo bazy danych geoprzestrzennych}
\author{Bartosz Rodziewicz}
\date{2019}

\begin{document}
\emergencystretch 3em

\pagestyle{empty}

\begin{center}{\huge
	\noindent\textsc{Politechnika Wrocławska}\par
	\noindent\textsc{Wydział Elektroniki}\\
	\noindent\hrulefill
}\end{center}

{\large
	\noindent
	\textsc{Kierunek: Informatyka}\\*
	\textsc{Specjalność: Systemy i Sieci Komputerowe}
}

\begin{center}{\Huge
	\noindent
	\textsc{Praca Dyplomowa}\\*\medskip
	\textsc{Inżynierska}
}\end{center}

\vspace{2.5cm}

\begin{multicols}{2}
\hfill\columnbreak

\begin{center}{\large
	\noindent
	Aplikacja mobilna na platformę Android umożliwiająca użytkowanie i uzupełnianie tworzonej społecznościowo bazy danych geoprzestrzennych

	\bigskip
	\noindent
	Mobile application for the Android platform facilitating use of and contribution to a crowdsourced geospatial database

	\bigskip
	\bigskip
	\bigskip
	\noindent
	\textsc{Autor:}\\*\bigskip
	Bartosz Rodziewicz
}\end{center}

\vspace{2cm}

{\large
	\noindent
	\textsc{Prowadzący pracę:}\\*
	Dr inż. Paweł Trajdos, W4/K2

	\bigskip
	\noindent
	\textsc{Ocena pracy:}\\*

}

\end{multicols}

\vfill

\begin{center}{\large
	\noindent\hrulefill\\
	\textsc{Wrocław, 2019}
}\end{center}



\tableofcontents

\pagestyle{plain}

\section{Wstęp}\label{preface}

W dzisiejszych czasach praktycznie każdy posiada smartfon. Większość z nich jest wyposażona, najczęściej w stałe, połączenie z Internetem. Pozwoliło to na wykształcenie się na rynku wielu aplikacji, których celem jest pomoc użytkownikowi w znalezieniu konkretnych informacji, w tym również geolokalizacyjnych. Istnieje wiele aplikacji oferujących dostęp do map, ułatwiających znajdywanie firm, wyświetlających aktualne położenie autobusów komunikacji miejskiej czy umożliwiających zlokalizowanie publicznych toalet w okolicy.

Celem tej pracy było przygotowanie aplikacji na urządzenia z systemem Android umożliwiającej użytkownikom na łatwiejsze znajdywanie miejsc użyteczności publicznej, gdzie goście mają dostęp do energii elektrycznej, np. restauracji, w której można usiąść przy stoliku z laptopem i podłączyć się do prądu. Aplikacja miała być klientem do niezależnie rozwijanego serwera z bazą danych i oferować możliwość wyświetlania zebranych w niej danych oraz umożliwiać operowanie na nich w przystępny i szybki dla użytkownika sposób.

Program ten miał być pisany wykorzystując najlepsze wzorce projektowe oraz odpowiednią warstwę abstrakcji, tak by jego dalszy rozwój był łatwy, nawet dla innej osoby. Dodatkowo miało to umożliwić łatwą zmianę przechowywanych danych w bazie, jeśli w przyszłości byłaby taka konieczność bądź chciano by wykorzystać ten projekt do stworzenia aplikacji podobnego typu.

Rozdział \ref{preface} stanowi wstęp do problemu. Rozdział \ref{concept} bardziej szczegółowo opisuje koncepcję aplikacji, jej zastosowanie i to co zostało zrealizowane. Rozdział \ref{technology} przedstawia technologie wybrane do stworzenia programu. Rozdział \ref{implementation} opisuje aspekty implementacji kodu oraz stanowi jego dokumentację. Rozdział \ref{ui} został wykorzystany do prezentacji i opisania interfejsu użytkownika aplikacji. W rozdziale \ref{summary} zamieszono podsumowanie pracy. Na końcu dokumentu znajdują się odwołania do literatury, z której korzystano w trakcie przygotowywania tej pracy oraz indeks użytych w pracy rycin i listingów.

\section{Opis koncepcji}\label{concept}
	\subsection{Aplikacja mobilna}

	Pomysł na aplikację powstał obserwując inne aplikacje użytkowe, jak te wymienione we wstępie. Głównie była ona bazowana na dwóch aplikacjach - aplikacji do wyszukiwania publicznych toalet (Flush) oraz publicznych sieci Wi-Fi (WiFi Map). W obu przypadkach głównym punktem wokół kręci się cała idea jest mapa z społecznie zbieranymi danymi przez użytkowników, którzy w założeniu sami dbają o poprawność i aktualność danych.

	Tutaj też głównym miejscem miał być widok mapy umożliwiający w przyjazny dla użytkownika sposób przeglądanie danych. Dodatkowo dane miały być możliwe do wyświetlenia w kwestii listy, sortowanej rosnąco odległością od użytkownika.

	Aby zmniejszyć obciążenie urządzenia oraz umożliwić pracę na dużej bazie danych klient miał pobierać punkty znajdujące się blisko lokalizacji użytkownika oraz te znajdujące się w zakresie widoku mapy, przeglądanej przez użytkownika. Z uwagi, że aplikacja prezentuje rzadko zmieniające się dane zmniejszenie zapytań do serwera miało być wykorzystane przez zapewnienie metody na buforowanie wyników zapytań na urządzeniu na jakiś czas, bądź do sytuacji, gdy aplikacja przekroczy dozwolony rozmiar pamięci buforu. Aplikacja miała również oferować ręczne sterowanie, który obszar będzie zapisany lokalnie na urządzeniu, aby umożliwić dostęp do danych w trybie offline.

	Baza miała przechowywać podstawowe dane o miejscu, jak jego lokalizacja czy nazwa oraz bardziej specyficzne dla tego zastosowania dane, jak ilość publicznie dostępnych gniazdek, czy szkic poglądowy z zaznaczonymi gniazdkami na planie budynku (co np. w przypadku restauracji ułatwiłoby klientowi wybranie odpowiedniego stolika, bez konieczności pytania obsługi). Planowana była też szersza integracja z Google Maps, aby miejsca w aplikacji można było przypisać do punktów POI (\textit{Points of interests}) znajdujących się w tym serwisie.

	W aplikacji miał być dostępny widok szczegółowy danego miejsca umożliwiający podejrzenie dodatkowych informacji o danym miejscu oraz historię ostatnich modyfikacji tego miejsca. Widok dodawania nowego miejsca miał umożliwić podanie wszystkich szczegółów dotyczących tego miejsca oraz miał ułatwiać naszkicowanie planu budynku ręcznie bądź umożliwić wgranie zdjęcia ręcznie wykonanego planu.

	Klient miał oczywiście pozwalać również na edycje już istniejących punktów, jak i usuwanie błędnie stworzonych, bądź już nie istniejących. Planowane było też wprowadzenie kont użytkownika, aby śledzić kto dokonuje modyfikacji oraz zablokować tych, którzy pogarszają jakość danych w aplikacji.

	\subsection{Serwer}

	Do działania aplikacja potrzebowałaby również internetowego serwera z bazą danych, jednak nie stanowi to przedmiotu tej pracy. Serwer miał być napisany w sposób umożliwiający tej aplikacji na połączenie się z nim oraz wykorzystując odpowiednią warstwę abstrakcji, by w przyszłości było możliwe stworzenie klientów na inne platformy (klient webowy, na system iOS, itp.)

	\subsection{Zakres realizacji}

	Oczywiście powyższy opis konceptu przekracza to co było planowane w zakresie tej pracy, oraz przekracza to co udało się zrealizować. W trakcie realizacji pracy udało się stworzyć następujące funkcjonalności:

	\begin{itemize}
		\item Możliwość przeglądania punktów w formie mapy i listy
		\item Możliwość dodawania, edycji i usuwania punktów
		\item Możliwość przeszukiwania bazy danych
		\item Połączenie z serwerem i synchronizacja danych
		\item Zapisywanie danych z serwera na urządzeniu, aby zminimalizować ilość zapytań
	\end{itemize}

	Jest to całkiem solidny zakres podstawowych funkcji umożliwiający na używanie aplikacji w założonych celach i jej dalszy rozwój.

\section{Wybrane technologie}\label{technology}
	\subsection{Platforma}

	Z punktu widzenia projektu wybór platformy mobilnej był jedynym słusznym wyborem, ponieważ aplikacja dostarcza informacje, które użytkownikom są potrzebne, gdy są w biegu, a nie siedzą w zaciszu swojego domu przed komputerem. Na rynku platform mobilnych aktualnie istnieje jedynie dwójka graczy, czyli Android od firmy Google oraz iOS od firmy Apple, mając udziały w rynku odpowiednio 77\% i 22\%. Z tych danych wychodzi jasny obraz, że aby dotrzeć do jak największej liczby użytkowników należy wybrać platformę Android. Dodatkowym aspektem skłaniającym do wyboru tej platformy był fakt posiadania przez autora pracy urządzeń działających pod kontrolą tego systemu.

	\subsection{Język programowania}

	Wybór platformy w dużej mierze uwarunkował wybór języka programowania. Istnieją oczywiście różne metody by pisać na Androida w wielu różnych językach (np. COBOL), jednak oficjalnie wspierane są następujące języki:

	\begin{itemize}
		\item Kotlin - nowy język, działający w JVM i będący w pełni interoperacyjny z Javą; od niedawna zalecany jako główny język dla nowych aplikacji przez Google
		\item Java - standardowy język, w którym od dawna powstają aplikację na tą platformę
		\item C++ - istnieje możliwość wykorzystania bibliotek napisanych w C++ za pomocą NDK udostępnionego przez Google, przydatne przy oprogramowaniu, dla którego kluczowa jest wydajność, czyli np. gier
		\item HTML+CSS+JS - częściowo wspierane jest tworzenie nowoczesnych stron internetowych zachowujących się jako aplikacje wykorzystując PWA
	\end{itemize}

	Taka sytuacja sprowadza się do wyboru pomiędzy dwoma językami: Kotlinem i Javą. Mimo pewnego wcześniejszego doświadczenia autora pracy z Javą wybrany został język Kotlin, który jest traktowany przez Google jako przyszłość dla tej platformy, aby ułatwić w przyszłości rozwój tej aplikacji i poznać nieznaną dotąd dla siebie technologię.

	\subsection{Zewnętrzne biblioteki}

	Przy budowie projektu wykorzystano kilka zewnętrznych bibliotek, z których większość wchodzi w skład Android Framework, czyli oficjalnych bibliotek wymaganych do tworzenia aplikacji na tą platformę.

	Podstawową użytą biblioteką jest biblioteka języka Kotlin, pozwalająca na pisanie kodu w tym języku oraz biblioteka Core z pakietu AndroidX, czyli główna biblioteka wymagana przez system, implementująca podstawowe definicje takich elementów jak aktywności czy widoki programu. Większość widoków w aplikacji stworzono wykorzystując ConstraintLayout, którego podstawowa definicja znajduje się w bibliotece o tej samej nazwie.

	Przy tworzeniu wykorzystano również bibliotekę AppCompat, która pozwoliła na modyfikacje paska akcji na górze widoku aplikacji i implementację mechanizmu wyszukiwania miejsc.

	Do wsparcia przy budowie nawigacji pomiędzy ekranami programu wykorzystano bibliotekę o nazwie Navigation, ponieważ jest to zalecona metoda tworzenia przejść przez Google. Z tego samego powodu wykorzystano bibliotekę Lifecycle do lepszego wsparcia zarządzania życiem poszczególnych elementów aplikacji.

	W programie zaimplementowano bazę danych w technologii SQLite wykorzystując bibliotekę Room, która pozwala w prosty sposób tworzyć bazy danych do aplikacji na platformę Android.

	Do obsługi map oraz lokalizacji wykorzystano biblioteki Google Maps Services, ponieważ jest to oficjalnie wspierana biblioteka do tych zastosowań.

	Obsługa połączenia z serwerem została zaimplementowana z pomocą biblioteki Retrofit, która pomaga w obsłudze zapytań HTTP wraz z biblioteką Moshi, która służy do automatyzacji parsowania modelu programistycznego do JSON i w drugą stronę. Biblioteka Moshi jest pierwszą użytą w projekcie biblioteką nie wchodzącą w skład Android Framework.

	Spoza Android Framework wykorzystano jeszcze jedną bibliotekę - Timber, która znacząco ułatwia korzystanie z systemowych logów platformy Android.

	\subsection{Komunikacja z serwerem}

	Aplikacja do kontaktu z serwerem wykorzystuje jego publiczne API oparte o zapytania HTTP i architekturę typu REST. Serwer nie posiada jeszcze domeny, więc aby się z nim połączyć konieczne jest uruchomienie go w sieci lokalnej i zmiana kodu aplikacji mobilnej podając jej poprawny adres działającego serwera. Serwer jednak nie był tematem tej pracy i został stworzony przez inną osobę.

	Aplikacja implementuje następujące zapytania do serwera:

	\begin{itemize}
		\item pobranie wszystkich punktów z bazy danych - zapytanie typu GET, które zwraca listę punktów;
		\item dodanie nowego punktu - zapytanie typu PUT, które w ciele przyjmuje obiekt z wszystkimi polami, bez Id, zwraca dodany obiekt do bazy danych z poprawnym Id;
		\item edycja istniejącego punktu - zapytanie typu PATCH, które przyjmuje zmieniony obiekt i go zwraca;
		\item usunięcie punktu - zapytanie typu DELETE, które przyjmuje obiekt do usunięcia i zwraca pustą odpowiedź z kodem HTTP 200.
	\end{itemize}

	Wszystkie zapytania wykorzystują to samu URI, jednak różnią się typem i zawartością ciała.

	\subsection{Środowisko deweloperskie}

	Projekt realizowany był z użyciem komputera wyposażonego w procesor Intel Pentium G3258@4.4GHz, 16GB pamięci RAM DDR3-1333 oraz kartę graficzną AMD Pitcairn XT na karcie Radeon HD 7870 z 2 GB pamięci, pracujący pod kontrolą systemu operacyjnego Microsoft Windows 10 Pro w wersji 1903 (Build 18362.476).

	Główny telefon wykorzystany do projektu to OnePlus 5T posiadający układ Snapdragon 835 i 6GB pamięci operacyjnej działający pod kontrolą systemu Android w wersji 9 Pie z nakładką OxygenOS w wersji 9.0.9.

	Program kompilowany był z użyciem Kotlina w wersji 1.3.60 do kodu bajtowego zgodnego z JVM w wersji 1.6. Proces budowania był sterowany przez narzędzie Gradle w wersji 5.4.1 z wtyczką do Androida (Android Gradle Plugin) w wersji 3.5.1. Kod edytowany był w środowisku deweloperskim (IDE) Android Studio w wersji 3.5.2.

	Najniższa wspierana przez aplikację wersja systemu Android to 5.0 Lollipop. Oprogramowanie było kompilowane używając SDK w wersji 29, odpowiadającej najnowszej wersji Androida 10.

	Aplikacja została przetestowana również na następujących urządzeniach:

	\begin{itemize}
		\item OnePlus One - Android 9 Pie
		\item Xiaomi Redmi Note 5A Prime - Android 7.1.2 Nougat
		\item Nokia 8 - Android 9 Pie
		\item Samsung Galaxy Tab 8.4 Pro - Android 7.1.2 Nougat (tablet)
		\item Nexus 5X - Android 10 (maszyna wirtualna)
		\item Nexus 4 - Android 5.0 Lollipop (maszyna wirtualna)
	\end{itemize}

	Na każdym z wymienionych urządzeń aplikacja działała w pełni poprawnie.

	\subsection{Kontrola wersji}

	W większości projektów informatycznych narzędzia systemu kontroli wersji pomagają zachować porządek i ułatwiają nad nim pracę. Z tego też powodu ten projekt również wykorzystywał narzędzie tego rodzaju - Git.

	Repozytorium Git wykorzystywane było głownie, aby lepiej zorganizować zmiany i łatwiej się w nich odnajdywać. Pozwalało na jednoczesną pracę nad kilkoma funkcjonalnościami jednocześnie, zachowując uporządkowaną historię zmian. Dodatkowo zabezpieczało ono sprawnie działający kod, pozwalając na cofnięcie niechcianych zmian w każdej chwili używając jednej komendy. System ten zapewniał też swojego rodzaju kopię zapasową projektu, ponieważ poza lokalnym komputerem repozytorium trzymane było również na serwerze GitHub w formie prywatnego projektu.

	\subsection{System budowania}

	Do automatyzacji procesu budowania wykorzystano narzędzie Gradle. Pozwalało ono po sprecyzowaniu podstawowych ustawień na w pełni automatyczne tworzenie pliku apk gotowego do instalacji na urządzeniu.

	W przypadku projektów na platformę Android konfiguracja Gradle, podzielona jest na dwa osobne pliki - konfiguracja do całego projektu oraz poszczególnego modułu. Mimo, że projekt posiadał tylko jeden moduł, zachowany został ten podział, ponieważ uważany jest on za dobrą praktykę.

	W pliku z konfiguracją na cały projekt podane zostały zdalne repozytoria, z których Gradle pobierał wymagane dependencje oraz zdefiniowane zostało użycie narzędzi wymaganych do zbudowania aplikacji na system Android.

	\begin{listing}[H]
		\caption{Konfiguracja narzędzia do budowy Gradle}
		\begin{minted}[tabsize=4,breaklines]{js}
compileSdkVersion 29
dataBinding {
	enabled = true
}
androidExtensions {
	experimental = true
}
buildToolsVersion "29.0.2"
defaultConfig {
	applicationId "test.mug.espresso"
	minSdkVersion 21
	targetSdkVersion 29
	versionCode 2
	versionName "0.1.1"
	testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
}
		\end{minted}
		\label{listing:gradle}
	\end{listing}

	W pliku konfiguracyjnym modułu programu znajdowały się podstawowe ustawienia (listing \ref{listing:gradle}).

	Zdefiniowana została wersje systemu Android, użyta do zbudowania binarki, minimalna wersja wymagana do działania programu oraz wersja narzędzia używanego do budowania. Aktywowano technologię data binding, która w prosty sposób umożliwia tworzenie powiązań pomiędzy kodem, a definicją widoku oraz aktywowano eksperymentalne funkcjonalności Android Framework.

	Ustalona została nazwa kodowa programu oraz jego wersja. Konwencja systemu Android jako nazwy kodowej zaleca stosowanie odwrotności domeny przeznaczonej dla danej aplikacji. Z uwagi, że do projektu nie została zarejestrowana jeszcze żadna domena, na czas realizacji pracy zdecydowano się użyć domeny test, która przeznaczona jest do użycia w testowaniu oprogramowania i gwarantuje pewność, że nigdy nie nastąpi konflikt z żadną istniejącą domeną, ponieważ zablokowana jest możliwość jej rejestracji.

	\subsection{Testy jednostkowe}

	Do projektu podłączono biblioteki JUnit umożliwiające pisanie lokalnych testów jednostkowych oraz testów wykonywanych na fizycznym urządzeniu. Niestety z uwagi na ograniczenia czasowe do aplikacji nie powstały żadne testy.

\section{Opis implementacji}\label{implementation}
	\subsection{Struktura}
		\subsubsection{Podział plików w projekcie}

		Nawet prosty projekt na platformę Android posiada dość skomplikowaną strukturę plików i wymaga chwili do zapoznania się z nią. Aplikacje na ten system pisane są w formie modułowej, jednak ten projekt posiada tylko jeden moduł o nazwie \texttt{app}.

		W głównym folderze projektu znajduje się kilka plików konfiguracyjnych dla narzędzia Gradle, które służy do automatyzacji procesu budowania.

		Folder \texttt{.idea} zawiera pliki konfiguracyjne środowiska IDE - Android Studio.

		Wszystkie pliki w folderze \texttt{app} to pliki należące do tego modułu, folder \texttt{app/src} zawiera 5 pod folderów, które w główny sposób dzielą kod aplikacji:

		\begin{itemize}
			\item \texttt{main} zawiera kod wspólny dla wszystkich metod budowania,
			\item \texttt{debug} to kod przeznaczony do budowania w tym trybie,
			\item \texttt{release} to kod przeznaczony do użycia przy budowaniu w trybie release, w tym projekcie te dwa powyższe foldery są używane do przechowywania osobnych plików z kluczem API do Google Maps,
			\item \texttt{test} i \texttt{androidTest} to foldery wykorzystywane przez testy jednostkowe.
		\end{itemize}

		Główny podział kodu znajduje się w katalogu \texttt{app/src/main}:

		\begin{itemize}
			\item folder \texttt{java} zawiera kod pisany w języku Java lub Kotlin (w tym projekcie tylko Kotlin), struktura pod folderów odpowiada nazwie kodowej aplikacji,
			\item folder \texttt{res} zawierający zasoby zapisane w formacie XML, gdzie najważniejsze to pliki definicji układu widoków (\texttt{res/layout}) oraz definicje menu (\texttt{res/menu}),
			\item \texttt{AndroidManifest.xml}, informujący system Android o strukturze tej aplikacji.
		\end{itemize}

		\subsubsection{Przepływ danych}

		\begin{figure}[H]
			\centering
			\includegraphics[width = \textwidth]{architecture}
			\caption{Schemat architektury}
			\label{fig:architecture}
		\end{figure}

		Z perspektywy obsługi danych architektura aplikacji była pisana wzorując się na sugerowanej przez Google strukturze. Została ona przedstawiona na Ryc. \ref{fig:architecture}.

		Stworzona została klasa pełniąca funkcję repozytorium, które jest pośrednikiem w dostępie do danych z bazy oraz obsługuje zapytania sieciowe by aktualizować zawartość bazy. Dostęp do repozytorium wykonywany jest z poziomu klas typu ViewModel, w których starano się zawrzeć jak największą część kodu odpowiedzialnego za manipulowanie danymi, tak aby kodu w klasach aktywności i fragmentów było jak najmniej, zostawiając tam tylko kod odpowiedzialny za obsługę interfejsu użytkownika. ViewModel odświeża dane wyświetlane na ekranie korzystając ze zmiennych LiveData i technologii data binding.

		\begin{listing}[H]
			\caption{Lista plików z kodem źródłowym (\textit{Pliki są wyświetlone w ręcznie ustalonej kolejności})}
			\begin{minted}[tabsize=4,breaklines]{text}
├── EspressoApplication.kt
├── mainView
│   ├── DataViewModel.kt
│   ├── ListViewFragment.kt
│   ├── MainActivity.kt
│   └── MapViewFragment.kt
├── detailView
│   ├── DetailViewFragment.kt
│   └── DetailViewModel.kt
├── addEditView
│   ├── AddViewFragment.kt
│   └── AddViewModel.kt
├── domain
│   ├── PowerMug.kt
│   └── PowerMugWithDistance.kt
├── repository
│   └── PowerMugRepository.kt
├── database
│   ├── DbPowerMug.kt
│   ├── PowerMugDatabase.kt
│   └── PowerMugDatabaseDao.kt
├── network
│   ├── NetworkPowerMug.kt
│   └── ServerApiService.kt
├── BindingAdapters.kt
└── Utils.kt
			\end{minted}
			\label{listing:files}
		\end{listing}

		Schemat ten ma swoje odbicie w układzie plików z folderze zawierającym kod źródłowy (listing \ref{listing:files}).

		Aplikacja składa się z jednej aktywności, której jedynym zadaniem jest załadowanie odpowiedniego fragmentu.

		Do każdego fragmentu (widoku) stworzony został odpowiedni ViewModel, z wyjątkiem dwóch głównych fragmentów - MapView i ListView, które posiadają jeden wspólny obiekt tego typu.

		Klasy reprezentujące struktury używane przez ViewModel zostały wydzielone do folderu \texttt{domain}. W kolejnych folderach pogrupowane są klasy wykorzystywane przez repozytorium, bazę danych i obsługę sieci.

		Na samym końcu znajdują się dwa zbiorcze pliki zawierające pomocnicze wolne funkcje (nie będące częścią żadnej klasy).

		\subsubsection{Widoki i nawigacja}

		\begin{figure}[H]
			\centering
			\includegraphics[width = \textwidth]{navigation}
			\caption{Diagram nawigacji pomiędzy fragmentami}
			\label{fig:navigation}
		\end{figure}

		Aplikacja posiada jedną aktywność i cztery widoki, w tym dwa główne. Aktywność przy tworzeniu aktywuje szablon nawigacji (znajdujący się w \texttt{res/navigation/}), który pomaga w bezproblemowym zarządzaniu przechodzeniem pomiędzy fragmentami. Schematyczny diagram tego szablonu został przedstawiony na Ryc. \ref{fig:navigation}.

		Głównym i domyślnym widokiem jest widok mapy. Uruchamia się on zaraz po starcie aplikacji. Umożliwia przeglądanie danych w postaci punktów na mapie zajmującej cały ekran. Kliknięcie na punkt powoduje wyświetlenie szczegółów danego miejsca.

		Drugim głównym widokiem jest widok pozwalający na wyświetlenie miejsc w formie sortowanej listy. Przejście do niego jest możliwe z głównego ekranu za pomocą przycisku na dole. Kliknięcie pozycji reprezentującej konkretne miejsce powoduje wyświetlenie się szczegółów.

		Oba widoki główne posiadają przycisk do dodania nowego miejsca, który przenosi do widoku dodawania. Po dodaniu następuje przejście do ekranu mapy. Ekran ze szczegółami poza wyświetlaniem dodatkowych informacji o miejscu pozwala na usunięcie miejsca z bazy. Po usunięciu następuje przejście do ekranu mapy.

		Android oferuje dwa rodzaje przejść pomiędzy ekranami - te co opisałem wyżej to przejścia w przód, które wykonywane są poprzez interakcje użytkownika z aplikacją. Drugim typem przejść są przejścia w tył wykonywane przez użycie przycisku wstecz. Tego typu przejścia powracają do poprzedniego ekranu. Aby nawigacja w aplikacji działała poprawnie i intuicyjnie dla użytkownika wszystkie przejścia "w przód" powracające do ekranu mapy powodują wyczyszczenie kolejki wcześniejszych widoków, aby kliknięcie przycisku wstecz na widoku mapy powodowało opuszczenie aplikacji.

	\subsection{Uruchomienie aplikacji i załadowanie mapy}

	Pierwszym krokiem po uruchomieniu aplikacji jest wykonanie się kodu z klasy Aplikacji (\texttt{EspressoApplication.kt}). Kod tam znajdujący się należy ograniczyć do minimum i w tym projekcie znajduje się tam jedynie aktywacja zewnętrznej biblioteki Timber pomagającej w tworzeniu logów.

	Następnie tworzona jest aktywność, która aktywuje szablon nawigacji ładujący główny widok, którym jest widok mapy.

	Podczas tworzenia się widoku mapy (metoda \texttt{onCreateView()}) następuje załadowanie definicji układu elementów widoku (znajdującej się w \texttt{res/layout/}). Dzięki wykorzystaniu data binding już w pliku layout przypisane są odpowiednie metody z ViewModel, które mają się wykonać po kliknięciu w przyciski. Następnie jest tworzona (bądź podłączona, jeśli już istnieje) instancja klasy ViewModel dla tego widoku.

	Przy tworzeniu ViewModel, tworzona jest instancja repozytorium. Po stworzeniu repozytorium, zostaje momentalnie zwrócona lista miejsc znajdująca się w bazie i następuje żądanie aktualizacji bazy poprzez połączenie z serwerem. Takie działanie powoduje, że użytkownik od razu po uruchomieniu aplikacji może z niej korzystać, zamiast czekać na pobranie się danych z serwera, które wcale nie musiały ulec zmianie. Po zakończeniu procesu pobierania repozytorium aktualizuje w tle dane w bazie oraz dzięki data binding zmiany te propagują się do wszystkich widoków aplikacji.

	Po stworzeniu ViewModel następuje stworzenie obserwatorów zmiennych LiveData w ViewModelu używanych do nawigacji oraz żądanie inicjalizacji mapy do biblioteki Google Maps Services i zapytanie użytkownika o pozwolenie na dostęp do lokalizacji (jeśli wcześniej nie zostało ono udzielone).

	Po poprawnej inicjalizacji mapy następuje stworzenie obserwatora listy punktów i wypełnienie mapy punktami. Następuje też przypisanie działania, które ma się wykonać po kliknięciu w dany punkt. Widok mapy przechodzi na aktualną pozycję użytkownika.

	Obecność elementu mapy zaburza poprawną implementację wzorca projektowego MVVM (Model-View-ViewModel), ponieważ część kodu odpowiedzialnego za obsługę map powinna zostać przeniesiona do ViewModela. Nie udało się tego jednak dokonać podczas realizacji tego projektu.

	\subsection{Wyszukiwanie punktów}

	Aplikacja oferuje wyszukiwanie punktów po nazwie lub adresie. Przeszukiwanie dostępne jest z poziomu przycisku znajdującego się na panelu na górze ekranu mapy.

	Przy tworzeniu menu (w trakcie tworzenia widoku) do obiektu wyszukiwania przypisywany jest \texttt{queryTextListener}, który zawiera definicje metod, które należy wywołać po zatwierdzeniu wyszukiwania.

	Wyszukiwanie polega na wykonaniu \texttt{queryTextListener.onQueryTextSubmit(String)}, czyli wysłaniu do repozytorium tekstu z pola wyszukiwania i czekaniu na wyniki. Repozytorium odpytuje bazę danych i zwraca do ViewModelu listę znalezionych miejsc.

	Po pojawieniu się wyników mapa jest czyszczona i pokazywane są na niej tylko znalezione miejsca oraz widok automatycznie przechodzi na pierwsze znaleziony punkt. W przypadku braku wyników pojawia się stosowny komunikat.

	Powrót do wyświetlania wszystkich miejsc jest możliwy wychodząc z wyszukiwania przyciskiem na górnym pasku aplikacji. Następuje wtedy wywołanie metody \texttt{closeListener}, która czyści mapę i ustawia ponownie ustawia obserwatora na domyślną zmienną LiveData z listą miejsc.

	\subsection{Przejście z użyciem data binding}\label{navigation}

	Większość przejść w tym projekcie realizowana jest zgodnie z poniższym schematem. Jest to zalecana metoda wykonywania przejść, ponieważ już w definicji układu widoku widać, do czego służy dany przycisk.

	\begin{listing}[H]
		\caption{Kod znajdujący się w klasie typu ViewModel potrzebny do przejścia}
		\begin{minted}[tabsize=4,breaklines]{java}
private var _navigateToSecondView = MutableLiveData<Boolean>()
val navigateToSecondView: LiveData<Boolean>
get() = _navigateToSecondView

fun goToSecondView() {
_navigateToSecondView.value = true
}

fun wentToSecondView() {
_navigateToSecondView.value = false
}
		\end{minted}
		\label{listing:navigation-viewmodel}
	\end{listing}

	\begin{listing}[H]
		\caption{Kod obserwatora potrzebny do przejścia}
		\begin{minted}[tabsize=4,breaklines]{java}
viewModel.navigateToSecondView.observe(viewLifecycleOwner, Observer {
		if (it == true) {
			this.findNavController()
				.navigate(R.id.action_mapViewFragment_to_listViewFragment)
			viewModel.wentToSecondView()
		}
	})
		\end{minted}
		\label{listing:navigation-view}
	\end{listing}

	Metoda polega na przypisaniu na kliknięcie w definicji układu widoku metody z ViewModela (w tym wypadku \texttt{goToSecondView()}). Metoda ta, zmienia wartość zmiennej LiveData (listing \ref{listing:navigation-viewmodel}) na którą ustawiony jest obserwator w widoku (listing \ref{listing:navigation-view}), który aktywuje się jeśli zmienna ma wartość \texttt{true}. Wywołuje on kontroler nawigacji i wykonuje odpowiednie przejście, po czym ustawia zmienną LiveData (w tym wypadku \texttt{\_navigateToSecondView}) na \texttt{false} wykorzystując drugą metodę (w tym wypadku \texttt{wentToSecondView()}). Ustawienie jej bezpośrednio jest niemożliwe, ponieważ jest to zmienna prywatna, a \texttt{navigateToSecondView} jest zmienną publiczną, której wartość nie może być modyfikowana - jest to zdefiniowane w ten sposób, aby zachować enkapsulację klasy.

	Konieczność wykonania takiego przepływu jest spowodowana faktem, że użycie kontrolera nawigacji jest możliwe tylko z poziomu kodu fragmentu, a nie kodu ViewModela.

	\subsection{Wyświetlenie listy miejsc}

	Wyświetlenie listy miejsc wymaga przejścia do widoku listy. Przejście z widoku mapy do widoku listy jest użyte jako przykład do opisu przejścia w podrozdziale powyżej.

	Zaimplementowany w tym projekcie widok listy wykorzystuje specjalny widok Android Framework o nazwie RecyclerView. Jest to widok przystosowany do wyświetlania bardzo dużych zbiorów danych bez wpływu na pamięć urządzenia. Widok ten zamiast tworzyć jedną długą listę i wyświetlać tylko jej fragment, tworzy listę zawierająco niewiele więcej elementów niż mieści się w jednej chwili na ekranie i wraz z przewijaniem wykorzystuje ponownie obiekty znikające do wyświetlenia nowych obiektów. Do działania jednak wymaga definicji obiektu typu ViewAdapter.

	Do stworzenia obiektu ViewAdapter wymagany jest obiekt ViewHolder, który operuje na definicji układu widoku pojedynczego elementu na liście. W tak podstawowej liście jak w tym projekcie, obiekt ten nie definiuje nic poza nazwą używanej definicji układu.

	Nawigacja do tego fragmentu powołuje wywołanie metody \texttt{onCreateView()}, która na samym początku ładuje definicję układu widoku oraz przypisuje się do ViewModela (tego samego co map view, więc przechodząc z map view mamy pewność, że on już istnieje).

	Z uwagi na brak konieczności ładowania mapy już na tym etapie ustawiani są obserwatorzy na zmienne wykorzystywane do nawigacji, jak i zmienne z listą punktów. Ten widok z uwagi na konieczność sortowania listy po odległości wykorzystuje jednak inną listę niż widok mapy. Lista potrzebna do tego widoku jest zdefiniowana w ViewModelu i jest tworzona w formie transformacji podstawowej listy wykorzystując dodatkowo aktualną lokalizację użytkownika.

	Do obliczenia odległości pomiędzy lokalizacją użytkownika, a punktem wykorzystywany jest następujący wzór, który zabezpiecza przed błędami zaokrągleń wynikających z precyzji arytmetyki zmiennoprzecinkowej \cite{haversineformulawiki}.

	<!-- wzor -->

	Na samym końcu tworzony jest obiekt typu ViewAdapter i zostaje on przypisany do parametrów RecyclerView.

	\subsection{Wyświetlenie widoku szczegółów}

	Przejście do tego fragmentu jest możliwe po kliknięciu na znacznik na mapie w widoku mapy bądź pozycje na liście w widoku listy. Przy przejściu następuje przekazanie jednego parametru (Id obiektu), którego szczegóły mają zostać wyświetlone.

	Tworzenie widoku rozpoczyna od załadowania definicji układu widoku i uzyskanie dostępu do repozytorium. Następnie wykonywane jest zapytanie do repozytorium o obiekt podając jego Id. Zapytanie nie korzysta z bazy danych, więc wykonywane jest na głównym wątku. Po otrzymaniu obiektu tworzony jest ViewModel wykorzystując do tego wzorzec projektowy fabryki (stworzenie ViewModela z parametrami w konstruktorze wymaga zdefiniowania fabryki).

	Następnie tworzeni są obserwatorzy zmiennych używanych do nawigacji, następuje żądanie inicjalizacji mapy oraz uzupełnione zostaje menu w pasku na górze ekranu.

	Po inicjalizacji mapy kamera zostaje przeniesiona na marker miejsca.

	\subsection{Usuwanie obiektu}

	Usunięcie wybranego obiektu jest możliwe poprzez opcję w menu na pasku akcji. Schemat wykorzystany do usuwania jest podobny do schematu przejścia opisanego w roździale \ref{navigation}.

	W momencie wybrania opcji następuje wyświetlenie nieskończonego paska postępu oraz zapytanie do repozytorium o usunięcie obiektu. Z uwagi na wykonywanie zapytania do serwera oraz do lokalnej bazy działanie to musi być wykonane na osobnym wątku.

	Po obsłużeniu zapytania repozytorium zwraca \texttt{Boolean}, czy udało się usuwanie, czy nie. Bazując na nim ustawiana jest trzystanowa LiveData, której obserwator podejmuje stosowne działanie przy zmianie wartości.

	Gdy usuwanie się uda następuje przejście do widoku mapy, w razie niepowodzenia pokazany zostaje komunikat i znika pasek postępu. Po obsłużeniu tej zmiany UI zmienna jest przywracana do stanu \texttt{UNSET}.

	\subsection{Dodawanie/edycja obiektu}

	Aby wykonać dodanie bądź edycję obiektu konieczne jest przejście do fragmentu \texttt{addViewFragment}. Dodanie jest możliwe z obu głównych widoków, natomiast edycja z widoku szczegółów. Wywołanie nawigacji wymaga podania Id zmienianego miejsca. Jeśli przejście następuje w celu stworzenia nowego obiektu podawany jest parametr \texttt{-1}. Jest to specjalnie zarezerwowany Id, który nigdy nie może pojawić się jako poprawny Id w bazie danych.

	Stworzenie widoku wygląda bardzo podobnie do widoku szczegółów. Jeśli podanym argumentem jest -1, zamiast poprawnego obiektu przekazywany jest \texttt{null}. Następuje żądanie inicjalizacji map i dostępu do lokalizacji użytkownika. Następnie tworzony jest pusty obiekt w ViewModelu i uzupełniany aktualną lokalizacją użytkownika. Na mapie w tym miejscu pojawia się też marker.

	Jeśli został podany Id poprawnego miejsca ViewModel jest tworzony z tym obiektem i po inicjalizacji map kamera przechodzi do lokalizacji edytowanego miejsca, a pola do edycji parametrów miejsca uzupełniają się aktualnymi wartościami.

	Kliknięcie w jakiekolwiek miejsce na mapie powoduje przeniesienie wskaźnika w nowe miejsca.

	Zapisanie dodania/edycji miejsca możliwe jest poprzez użycie przycisku na dole ekranu. Wykorzystywany jest podobny schemat, jak przy usuwaniu i przejściu. Wysyłane jest wtedy odpowiednie zapytanie do repozytorium i następuje oczekiwanie na wynik. Przy poprawnej akcji program przechodzi do widoku mapy, przy negatywnym następuje informacja o błędzie.

	\subsection{Implementacja repozytorium}

	Model repozytorium w tym projekcie pełni funkcję warstwy abstrakcji pomiędzy zapytaniami do serwera i bazy oraz powoduje skupienie całego kodu odpowiedzialnego za te operacje w jednym miejscu. Repozytorium jest zaimplementowane w formie wzorca projektowego typu Singleton, zapewniającego, że w trakcie życia aplikacji będzie istniał tylko jeden obiekt repozytorium i bazy danych.

	\begin{listing}[H]
		\caption{Publiczny interfejs repozyterium}
		\begin{minted}[tabsize=4,breaklines]{java}
val powerMugs: LiveData<List<PowerMug>>

suspend fun refreshCache()

suspend fun updatePlace(powerMug: PowerMug): Boolean
suspend fun insertPlace(powerMug: PowerMug): Boolean
suspend fun deletePlace(powerMug: PowerMug): Boolean

fun search(query: String): LiveData<List<PowerMug>>

fun returnPlace(key: Long): PowerMug?
		\end{minted}
		\label{listing:repository}
	\end{listing}

	Użycie repozytorium sprowadza się do wywołania jednej z publicznych metod jego interfejsu z dowolnego miejsca aplikacji. Metody wypisane są w listingu \ref{listing:repository}.

	Użycie metod typu \texttt{suspend} konieczne jest z poziomu współprogramów (ang. coroutines), aby zapobiec blokowaniu wątku głównego programu odpowiedzialnego za wyświetlanie elementów interfejsu użytkownika.

	Wszystkie metody działające we współprogramach mają podobny schemat działania - najpierw konkretne działanie jest wykonywane na serwerze, po czym w przypadku powodzenia zmiana zapisywana jest w lokalnej bazie danych, z której korzysta program. Zwracany obiekt typu \texttt{Boolean} informuje o sukcesie bądź niepowodzeniu danej akcji.

	\subsection{Przechowywanie obiektów}

	Mimo, że program w każdym miejscu wykorzystuje bardzo podobną definicje klasy poszczególnego punktu na mapie, zdecydowano się rozdzielić ich definicje na 3 osobne - definicję dla logiki programu (domenową - \texttt{PowerMug}), do bazy danych (\texttt{DbPowerMug}) i do zapytań sieciowych (\texttt{NetworkPowerMug} oraz \texttt{EphemeralNetworkPowerMug}). Tego typu rozdzielenie nie było konieczne, jednak powoduje, że kod aplikacji staje się bardziej elastyczny i modyfikacja np. modelu bazy nie powoduje konieczności wprowadzenia modyfikacji w kodzie całej aplikacji.

	\begin{listing}[H]
		\caption{Metody używane do konwersji pomiędzy modelami obiektów}
		\begin{minted}[tabsize=4,breaklines]{java}
fun PowerMug.asDbModel(): DbPowerMug
fun PowerMug.asNetworkModel(): NetworkPowerMug
fun PowerMug.asEphemeralNetworkModel(): EphemeralNetworkPowerMug

fun DbPowerMug.asDomainModel(): PowerMug
fun List<DbPowerMug>.asDomainModel(): List<PowerMug>

fun NetworkPowerMug.asDatabaseModel(): DbPowerMug
fun List<NetworkPowerMug>.asDatabaseModel(): Array<DbPowerMug>
		\end{minted}
		\label{listing:model-conversion}
	\end{listing}

	Aby uprościć zamianę obiektów jednej reprezentacji w drugą przygotowano specjalne metody poszczególnych klas (listing \ref{listing:model-conversion}).

\section{Opis interfejsu użytkownika}\label{ui}
	\subsection{Ekrany główne}

	\begin{figure}[H]
		\centering
		\includegraphics[width = \textwidth]{screenshot-main}
		\caption{Dwa główne widoki programu}
		\label{fig:screenshot-main}
	\end{figure}

	Aplikacja posiada dwa główne ekrany - widok mapy i widok listy. Ich wygląd został przedstawiony na Ryc. \ref{fig:screenshot-main}. Oba posiadają pasek na dole służący do nawigacji i przełączania pomiędzy nimi. W prawym dolnym rogu każdego z nich znajduje się "pływający" przycisk służący do dodawania nowego obiektu.

	Na widoku mapy cały ekran zajęty jest przez fragment Google Maps, wyświetlający wszystkie punkty w formie markerów w odpowiednich miejscach geograficznych. Kliknięcie na dany marker przenosi do ekranu ze szczegółami o konkretnym miejscu. Na górnym pasku poza nazwą aplikacji wyświetlany jest przycisk uruchamiający tryb wyszukiwania.

	W formie listy cały ekran jest zajęty przez przewijaną listę miejsc, posortowaną rosnąco odległością od aktualnej lokalizacji użytkownika. Kliknięcie na dowolną pozycję na liście powoduje przeniesienie do ekranu ze szczegółami o tym miejscu.

	\subsection{Wyszukiwanie punktów}

	\begin{figure}[H]
		\centering
		\includegraphics[width = \textwidth]{screenshot-search}
		\caption{Wygląd trybu wyszukiwania miejsc}
		\label{fig:screenshot-search}
	\end{figure}

	Wyszukiwanie markerów na mapie odbywa się w widoku mapy. Po kliknięciu na ikonę wyszukiwania pojawia się pasek, gdzie należy wpisać szukany ciąg znaków. Miejsca przeszukiwane są po nazwie i adresie. Wyszukiwanie zatwierdzane jest za pomocą przycisku na klawiaturze ekranowej.

	W przypadku nieznalezienia żadnych wyników wyświetla się komunikat o błędzie, natomiast w przypadku powodzenia mapa ograniczy wyświetlane markery do tych spełniających kryteria wyszukiwania, a kamera przenosi się na pierwsze spełniające zapytanie miejsce.

	Opuszczenie wyszukiwania i powrót do wszystkich miejsc następuje poprzez kliknięcie w przycisk X na pasku szukania.

	Ryc. \ref{fig:screenshot-search} przedstawia po kolei: pasek wyszukiwania, pasek uzupełniony szukaną frazą oraz błąd, gdy nie znaleziono żadnych wyników.

	\subsection{Tryb edycji i dodawania obiektów}

	\begin{figure}[H]
		\centering
		\includegraphics[width = \textwidth]{screenshot-addedit}
		\caption{Możliwy wygląd ekranu dodawania/edycji punktu na mapie}
		\label{fig:screenshot-addedit}
	\end{figure}

	Widok dodawania i edycji to jeden widok. W przypadku dodawania widok nie zawiera żadnych danych o miejscu, a marker na mapie wyświetla się na aktualnej lokalizacji użytkownika. W przypadku edycji widok wypełnia się aktualnym informacjami o miejscu.

	Zmiana pozycji markera odbywa się poprzez kliknięcie na nową lokalizację na mapie.

	Zapisanie danych jest możliwe po kliknięciu przycisku w prawym dolnym rogu. Przy zapisywaniu danych pojawia się nieskończony pasek postępu, który znika po zakończeniu procesu dodawania. Przy niepowodzeniu następuje wyświetlenie stosownego komunikatu, natomiast po poprawnym dodaniu aplikacja wraca do głównego ekranu mapy.

	Wyjście z ekranu bez zapisywania zmian jest możliwe używając sprzętowe klawisza "cofnij" lub przycisku na górnej belce widoku.

	Ryc. \ref{fig:screenshot-addedit} przedstawia po kolei: widok po otwarciu trybu dodawania, widok trybu edycji, pasek postępu przy zapisywaniu zmian oraz komunikat o błędzie przy zapisywaniu.

	\subsection{Widok szczegółowy i usuwanie miejsc}

	\begin{figure}[H]
		\centering
		\includegraphics[width = \textwidth]{screenshot-detail}
		\caption{Ekran szczegółów wraz z błędem usuwania}
		\label{fig:screenshot-detail}
	\end{figure}

	Fragment ze szczegółami niewiele różni się wyglądem od trybu edycji. Nie oferuje on jednak możliwości zmiany żadnych informacji.

	Usunięcie miejsca jest możliwe z poziomu pozycji w menu na górnym pasku aplikacji. Po wywołaniu usuwania miejsca, tak jak w przypadku dodawania wyświetla się okrągły pasek postępu. Niepowodzenie jest sygnalizowane odpowiednim komunikatem, a sukces przejściem do głównego ekranu mapy.

	Z tego widoku możliwe jest również przejście do widoku edycji korzystając z przycisku w prawym dolnym rogu. Wyjście, czyli powrót do widoku mapy lub listy jest możliwe używając sprzętowego przycisku, bądź przycisku na górnym pasku.

	Ryc. \red{fig:screenshot-detail} przedstawia po kolei: widok szczegółów, menu widoku szczegółowego oraz błąd przy usuwaniu miejsca.

\section{Podsumowanie}\label{summary}

\printbibliography[heading=bibintoc,title={Literatura}]

\renewcommand{\section}{\sectioncmd}
\clearpage

\addcontentsline{toc}{section}{Indeks rycin}
\listoffigures

\addcontentsline{toc}{section}{Indeks listingów}
\listoflistings

\end{document}
